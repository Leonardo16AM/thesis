\chapter{Estado del Arte}\label{chapter:state-of-the-art}

La síntesis de vistas novedosas ha experimentado un notable progreso en los últimos años, impulsada principalmente por representaciones volumétricas explícitas como alternativa eficiente frente a métodos implícitos como NeRF. Entre estas técnicas, destacan especialmente aquellas basadas en primitivas de tipo \textit{splatting}, siendo el \textit{Gaussian Splatting} clásico una referencia fundamental por su balance entre calidad visual y velocidad de renderizado. Sin embargo, la representación con primitivas Gaussianas presenta limitaciones, particularmente en la precisión geométrica de bordes y detalles finos, impulsando múltiples investigaciones hacia variaciones y mejoras sustanciales. Este capítulo revisa los principales avances en representaciones basadas en \textit{splatting}, abordando tanto modificaciones en la forma de las primitivas como cambios en los métodos de rasterización y renderizado. Asimismo, se exploran brevemente otras representaciones volumétricas recientes, proporcionando una visión comparativa crítica en términos de calidad visual, precisión geométrica y eficiencia computacional.

%region GAsussian splatting clasico
\section{Gaussian Splatting clásico}

El \textbf{Gaussian Splatting 3D} clásico [\cite{kerbl20233d}] representa la escena tridimensional mediante un conjunto explícito de miles o incluso millones de primitivas Gaussianas anisotrópicas (comúnmente llamadas \textit{splats}), distribuidas espacialmente. Cada Gaussiana $g_i$ se caracteriza por un conjunto específico de parámetros:

\begin{itemize}
    \item Posición tridimensional: $\mathbf{p}_i \in \mathbb{R}^3$.
    \item Matriz de covarianza anisotrópica tridimensional $\mathbf{\Sigma}_i \in \mathbb{R}^{3 \times 3}$ que determina la forma y orientación del \textit{splat}.
    \item Color dependiente o independiente del punto de vista, típicamente representado mediante armónicos esféricos (SH) de bajo orden:
    \[
    \mathbf{c}_i(\mathbf{d}) = \sum_{l=0}^{L} \sum_{m=-l}^{l} c_{i}^{l,m} Y_{l}^{m}(\mathbf{d}),
    \]
    donde $\mathbf{d}$ es la dirección de vista y $Y_{l}^{m}$ son los armónicos esféricos. En la práctica, se utiliza un orden bajo ($L \leq 2$), lo que implica 9 coeficientes por canal de color.
\end{itemize}

A diferencia de métodos basados en campos de radiancia implícitos como NeRF, el renderizado de la escena no utiliza \textit{ray marching} denso ni evaluaciones continuas de redes neuronales, sino que se basa en la rasterización eficiente de estas primitivas Gaussianas. El procedimiento consiste en proyectar cada Gaussiana desde el espacio tridimensional al plano de imagen mediante una transformación de proyección:

\[
\mathbf{x}_i = \mathbf{K} [\mathbf{R} | \mathbf{t}] \mathbf{p}_i^{\text{h}},
\]
donde $\mathbf{K}$ es la matriz de calibración intrínseca de la cámara, $[\mathbf{R}|\mathbf{t}]$ representa la pose (rotación y traslación) de la cámara, y $\mathbf{p}_i^{\text{h}} = (\mathbf{p}_i^\top, 1)^\top$ son las coordenadas homogéneas del punto.

La covarianza tridimensional original se proyecta al plano de imagen siguiendo el modelo de \cite{zwicker2001ewa}, produciendo una Gaussiana 2D elipsoidal con matriz de covarianza proyectada:

\[
\mathbf{\Sigma}_i' = \mathbf{J} \mathbf{\Sigma}_i \mathbf{J}^\top,
\]
donde $\mathbf{J}$ es el Jacobiano de la transformación proyectiva respecto a las coordenadas 3D, evaluado en $\mathbf{p}_i$.

Durante la rasterización, cada Gaussiana proyectada actúa como un \textit{billboard} semi-transparente cuya contribución al color final del píxel se obtiene mediante composición alfa. La formación de imagen sigue el mismo modelo volumétrico que NeRF, pero adaptado a una representación discreta. El color de un píxel se calcula como:

\[
\mathbf{C}(x,y) = \sum_{i=1}^{N} T_i \alpha_i(x,y) \mathbf{c}_i,
\]
donde:

\[
T_i = \prod_{j<i} (1 - \alpha_j(x,y)),
\]
representa la transmitancia acumulada a lo largo del rayo hasta el splat $i$, y la opacidad puntual $\alpha_i(x,y)$ está dada por la evaluación de la Gaussiana proyectada:

\[
\alpha_i(x,y) = \alpha_{i}^{\max} \exp\left(-\frac{1}{2}\mathbf{u}^{T}\mathbf{\Sigma}_i'^{-1}\mathbf{u}\right),
\]
siendo $\mathbf{u} = \begin{pmatrix}x \\ y\end{pmatrix} - \mathbf{x}_i$ la diferencia respecto al centro proyectado del splat, y $\alpha_i^{\max}$ su opacidad máxima aprendida. En algunas implementaciones, este valor puede incluir el factor de normalización de la Gaussiana 2D $(2\pi \sqrt{|\Sigma_i'|})^{-1}$.

Esta formulación es equivalente al modelo de renderizado volumétrico de NeRF, en el que:

\[
\alpha_i = 1 - \exp(-\sigma_i \delta_i),
\]
y puede recuperarse de la expresión anterior al interpretar la evaluación de la Gaussiana como una densidad efectiva:

\[
\sigma_i \delta_i \approx -\ln \left( \alpha_i(x,y)/\alpha_i^{\max} \right).
\]

El uso de composición alfa con ordenamiento por profundidad (frontal a trasero) garantiza que se respete la visibilidad, lo que mejora la calidad visual y evita artefactos como el \textit{popping} visual. Este fenómeno, causado por inconsistencias discretas entre capas de splats, se mitiga mediante estrategias como la ordenación aproximada por tiles y la adición de ligeras perturbaciones aleatorias.

La optimización de la escena con \textit{Gaussian Splatting} comienza a partir de una nube de puntos inicial obtenida mediante técnicas como \textit{Structure from Motion}. A partir de esta inicialización, los parámetros de cada Gaussiana (posición, covarianza, opacidad y color) se ajustan mediante descenso por gradiente en una función de pérdida fotométrica. Para evitar problemas numéricos, las matrices de covarianza $\Sigma_i$ se parametrizan como:

\[
\mathbf{\Sigma}_i = \mathbf{R}_i \mathbf{S}_i \mathbf{S}_i^\top \mathbf{R}_i^\top,
\]
donde $\mathbf{S}_i$ es una matriz diagonal con los escalados y $\mathbf{R}_i$ es una matriz de rotación representada por cuaterniones.

Adicionalmente, se emplean técnicas de densificación adaptativa para insertar o eliminar Gaussianas de manera dinámica según criterios locales de error. Esto permite capturar estructuras finas sin necesidad de usar una representación extremadamente densa desde el inicio, mejorando la eficiencia computacional.

Esta representación explícita presenta ventajas claras en términos de paralelismo, facilidad de actualización local y escalabilidad. Sin embargo, al tratarse de funciones suaves con soporte infinito, las Gaussianas tienden a comportarse como filtros paso-bajo. Como consecuencia, las discontinuidades marcadas en geometría o color (bordes duros) son difíciles de representar sin introducir una gran cantidad de splats agrupados en esas regiones. Esta limitación motiva investigaciones posteriores que buscan mejorar la representación local sin comprometer la eficiencia del renderizado.

%region REpresentaciones basadas en splatting
\section{Representaciones basadas en \textit{splatting}}

Tras el éxito del splatting \textit{Gaussian Splatting} clásico, han surgido numerosas variantes y extensiones que modifican la forma de las primitivas o el procedimiento de renderizado para mejorar la calidad (especialmente en bordes, detalles y estructura geométrica) y la eficiencia (en términos de velocidad de render y número de primitivas). A continuación se describen las principales representaciones basadas en splatting, distinguiendo sus contribuciones.

%region 2D Gaussian splatting
\subsection{2D Gaussian Splatting}  

En contraste con el enfoque volumétrico de \textit{3D Gaussian Splatting}, el método \textbf{2D Gaussian Splatting (2DGS)} colapsa cada elipsoide Gaussiano 3D en un disco orientado (“surfel”) a un plano alineado con la superficie local [\cite{Huang_2024}] . Esto reduce el ruido geométrico y mejora la consistencia entre vistas sin perder la eficiencia del splatting. Cada surfel se define por una posición $\mathbf{x} \in \mathbb{R}^3$, dos vectores tangenciales ortogonales $\mathbf{u}, \mathbf{v}$ que determinan su plano y escalas $\sigma_u, \sigma_v$ sobre esas direcciones; la escala normal es cero, lo que aplana la Gaussiana.  


Para renderizar, 2DGS calcula la intersección entre el rayo de cámara y el plano del surfel, evaluando la densidad Gaussiana en el punto de intersección si está dentro de la elipse. Se acumulan las contribuciones con \textit{alpha blending} ordenado por profundidad. Esto evita errores de perspectiva y mejora la representación de bordes afilados.

El entrenamiento es diferenciable y se realiza directamente en GPU. Se retropropagan gradientes respecto a posición, orientación, escala y color. Además de la pérdida fotométrica, se usan dos términos de regularización clave: (1) \textit{pérdida de distorsión de profundidad}, que penaliza distribuciones extendidas en profundidad forzando superficies definidas; y (2) \textit{pérdida de consistencia de normales}, que alinea las normales implícitas de los surfels con las derivadas del mapa de profundidad [\cite{Huang_2024}].Gracias a esto, 2DGS produce superficies más limpias y coherentes entre vistas, permitiendo generar mallas detalladas mediante fusionado de mapas de profundidad. 

%region Gaussian SUrfels
\subsection{Gaussian Surfels}

\textbf{Gaussian Surfels} [\cite*{dai2024highqualitysurfacereconstructionusing}] extiende la idea de 2DGS proponiendo surfels gaussianos planos desde el inicio, con $\sigma_z = 0$, eliminando completamente la ambigüedad en la orientación. Cada surfel se parametriza por su posición $\mathbf{x}$, orientación local (incluyendo la normal), escalas $\sigma_1, \sigma_2$ en el plano, opacidad y color. El renderizado y la composición por \textit{alpha blending} son equivalentes a 2DGS.

Un aspecto distintivo es la optimización geométrica: como $\sigma_z = 0$, mover el surfel a lo largo de su normal no afecta directamente la imagen, por lo que se introduce una \textit{pérdida de consistencia profundidad-normal}, que alinea las normales de los surfels con las derivadas del mapa de profundidad. Además, se aprovechan normales estimadas a partir de las imágenes y se penalizan opacidades muy bajas para evitar contribuciones fantasmas.

Una vez entrenado, el método aplica un \textit{corte volumétrico} que filtra puntos espurios en los mapas de profundidad y permite ensamblar una malla final con \textit{reconstrucción Poisson} con restricciones de borde. El resultado es una malla precisa, suave y detallada.

\textit{Gaussian Surfels} mejora la precisión geométrica frente a representaciones volumétricas implícitas como NeRF, y converge rápidamente gracias a su simplicidad y orientación superficial explícita. En escenas reales, logra reconstrucciones superiores con tiempos de entrenamiento de pocos minutos [\cite{dai2024highqualitysurfacereconstructionusing}].

%region LinPrim
\subsection{LinPrim (Primitivas Lineales)}

Mientras que los métodos anteriores se basan en kernels gaussianos (o variaciones de estos), \textbf{LinPrim} toma un camino diferente: introduce primitivas basadas en octaedros y tetraedros, que son poliedros convexos con caras planas y definen volúmenes homogéneos de color y densidad constante en su interior [\cite{von2025linprim}]. En esencia, en lugar de aproximar la escena mediante nubes continuas de densidad gaussiana, este método tesela el espacio con poliedros cuyos interiores actúan como volúmenes opacos emisores de color. Para optimizar estas primitivas en un contexto diferenciable, LinPrim desarrolla un rasterizador especializado que permite renderizar eficientemente octaedros y tetraedros en GPU, calculando exactamente la intersección entre cada primitiva y el rayo de visión, y contribuyendo al color final de forma diferenciable.

Una motivación clave de LinPrim es lograr una representación volumétrica más afín a las geometrías típicas utilizadas en gráficos tradicionales. Dado que las primitivas son poliedros lineales, se integran naturalmente con flujos de trabajo basados en mallas; por ejemplo, es sencillo exportar o convertir la escena reconstruida en una malla convencional sin grandes pérdidas, puesto que conceptualmente la escena ya está compuesta por elementos poligonales discretos.

En términos de calidad visual, los resultados de LinPrim presentan una fidelidad comparable con técnicas volumétricas gaussianas y neuronales del estado del arte, logrando reconstruir escenas con alta calidad visual. Sin embargo, LinPrim consigue esto con una cantidad significativamente menor de primitivas: al ser cada octaedro o tetraedro más voluminoso comparado con las gaussianas, se requieren menos elementos para cubrir toda la escena. Esto implica mayor eficiencia en memoria y, potencialmente, menor tiempo de cómputo. De hecho, LinPrim reporta alcanzar fidelidad visual cercana a \textit{3D Gaussian Splatting} utilizando varios órdenes de magnitud menos primitivas.

La rasterización de primitivas lineales también permite implementaciones altamente optimizadas, alcanzando tasas de cuadro interactivas (\~ 30 FPS), similares a \textit{3D Gaussian Splatting}. No obstante, una diferencia importante reside en cómo maneja las transiciones: las primitivas lineales, debido a su densidad constante, pueden representar bordes perfectamente nítidos (donde las caras de los poliedros actúan como planos de corte). Esta misma característica puede dificultar la optimización, dado que pequeños errores en la posición u orientación de una cara pueden generar discontinuidades notables. Para mitigar este problema, LinPrim utiliza subdivisión adaptativa durante la optimización, dividiendo las primitivas en regiones geométricamente complejas, similar al proceso de densificación en el \textit{Gaussian Splatting}, permitiendo que la escena se refine progresivamente.

LinPrim demuestra que es viable salir del dominio gaussiano y utilizar primitivas geométricas explícitas y lineales, obteniendo fidelidad visual comparable con menos elementos y ofreciendo mejor compatibilidad con representaciones estándar, aunque a costa de una implementación más compleja en términos de rasterización diferenciable.


%region EVER
\subsection{EVER (Exact Volumetric Ellipsoid Rendering)}

El método \textbf{EVER} (\textit{Exact Volumetric Ellipsoid Rendering}) propone una reformulación del \textit{Gaussian Splatting} para lograr una integración volumétrica exacta de primitivas elipsoidales [\cite{mai2024ever}]. A diferencia del método clásico de \textit{3D Gaussian Splatting}, que utiliza rasterización aproximada mediante composición alfa de \textit{"billboards"} discretizados, EVER modela cada primitiva como un elipsoide volumétrico continuo con densidad emisiva, realizando la renderización mediante un trazado de rayos volumétrico \textit{analítico}. En otras palabras, en lugar de hacer composición alfa utilizando sprites 2D, EVER calcula exactamente la contribución luminosa al atravesar cada elipsoide con un rayo, resolviendo la integral volumétrica de forma cerrada.


En términos de rendimiento, EVER alcanza velocidades de renderizado en tiempo real (\~30 FPS a resolución 720p en hardware moderno), gracias al uso eficiente de la paralelización mediante trazado de rayos en GPU y optimizaciones matemáticas para las intersecciones rayo-elipsoide. Aunque su velocidad es ligeramente inferior al 3DGS rasterizado, que puede superar los 60 FPS, la calidad obtenida generalmente compensa esta diferencia. EVER produce imágenes más precisas y estables, especialmente al reducir problemas de mezcla incorrecta (\textit{blending}) en regiones de alta densidad de splats, ya que la formulación volumétrica exacta preserva correctamente la contribución acumulativa de densidades, evitando duplicaciones o pérdidas.

Un beneficio significativo del método EVER es su capacidad natural para manejar efectos complejos que resultan difíciles mediante rasterización. Por ejemplo, incorpora directamente desenfoque por profundidad de campo (\textit{defocus blur}) y distorsiones de lente (como las de tipo ojo de pez) durante el proceso de renderizado, dado que el enfoque analítico utiliza rayos continuos atravesando volúmenes. Esto extiende sus aplicaciones hacia contextos donde la cámara presenta propiedades no pinhole, algo que en 3DGS requiere soluciones específicas adicionales. 

Los experimentos indican que, en escenas de gran escala y complejidad (por ejemplo, el conjunto de datos Zip-NeRF), EVER proporciona resultados más nítidos entre las técnicas de tiempo real, superando a 3DGS y variantes previas en la reproducción de detalles finos y bordes precisos.
%region GES
\subsection{GES (Generalized Exponential Splatting)}

Reconociendo la limitación fundamental de las funciones Gaussianas (su naturaleza de baja frecuencia intrínseca), el método GES introduce un \textit{Generalized Exponential Splatting} que utiliza funciones exponenciales generalizadas en lugar de Gaussianas para representar la densidad  [\cite{hamdi2024ges}]. Concretamente, emplea una función exponencial generalizada (GEF) paramétricamente ajustable como núcleo de cada splat. Mediante un parámetro de forma adicional, estas funciones pueden volverse más puntiagudas o más planas que una Gaussiana estándar, permitiendo modelar distribuciones con colas más cortas o concentraciones más agudas de densidad. En el límite, una GEF puede aproximar funciones de alta frecuencia, a diferencia de la Gaussiana que siempre impone un filtrado suave. Gracias a esta flexibilidad, GES logra representar con gran fidelidad señales o detalles de bordes que para \textit{Gaussian Splatting} requerirían una explosión en el número de primitivas. Por ejemplo, se demuestra teóricamente que una combinación de GEFs puede ajustar señales con transiciones abruptas (esquinas, rampas) con menor cantidad de elementos que la combinación equivalente de Gaussianas, reduciendo la necesidad de que el algoritmo introduzca multitud de splats pequeños para aproximar un borde.

En la práctica, GES se integra como un reemplazo directo en el pipeline de \textit{Gaussian Splatting}: las mismas utilidades de optimización y rasterización se adaptan para trabajar con las funciones exponenciales generalizadas en lugar de Gauss. Esto resulta en un sistema que mejora la eficiencia y preserva o mejora la calidad sin cambiar drásticamente el \textit{framework}. Empíricamente, GES puede lograr la misma calidad que 3DGS utilizando menos de la mitad de las primitivas, lo que implica no solo menor memoria sino también cálculos más rápidos al renderizar. De hecho, se reporta un aumento de hasta un 39\% en la velocidad de render frente al método Gaussiano, debido principalmente a la reducción de splats necesarios. En términos de calidad visual, las imágenes producidas presentan bordes y patrones de alta frecuencia más nítidos y libres de difuminado, confirmando que la mayor flexibilidad de la GEF permite sortear la limitación pasa-bajos de las Gauss. No obstante, cabe señalar que las funciones exponenciales generalizadas mantienen simetría radial (al igual que las Gauss), por lo que aunque capturan mejor la distribución radial de densidad, no introducen anisotropías novedosas por sí mismas (siguen siendo “bolas” ajustables en intensidad pero esencialmente esféricas en iso-superficies). Aun así, GES ha probado ser un avance importante en la búsqueda de representaciones más compactas y precisas: al disminuir la carga de memoria y cómputo sin perjuicio de la fidelidad, este enfoque aumenta el atractivo práctico de los métodos de splatting para aplicaciones en dispositivos con recursos limitados o para escenas muy complejas.

%region 3D-HGS
\subsection{3D-HGS (3D Half-Gaussian Splatting)}

Tanto GES como EVER abordan la limitación de las Gaussianas desde perspectivas diferentes (cambiar la función base o hacer integración exacta). Otro enfoque complementario es modificar la forma de la propia función Gaussiana para adaptarla a discontinuidades. En esta línea se sitúa \textbf{3D-HGS}, o \textit{3D Half-Gaussian Splatting}, que propone el uso de \textit{medias Gaussianas} como primitivas [\cite{li20243d}]. La idea central es que una distribución Gaussiana completa, simétrica, no es ideal para modelar regiones cerca de un borde: difumina a ambos lados de manera igual. 3D-HGS en cambio define kernels que esencialmente corresponden a una mitad de una función Gaussiana, cortada por un plano. De este modo, una \textit{half-Gaussian} decae gradualmente en una dirección (hacia el interior de un objeto, por ejemplo) pero es abruptamente truncada en la dirección opuesta (coincidiendo con la superficie o borde). Estas primitivas pueden alinearse con los contornos de los objetos, permitiendo representar de forma nativa discontinuidades de forma y color donde las Gaussianas convencionales fallarían.

Implementar 3D-HGS como mejora de 3DGS es relativamente sencillo: se integra como un \textit{plug-and-play} en los pipelines existentes, sustituyendo el kernel Gaussiano por esta variante asimétrica. Los experimentos han mostrado que al entrenar con 3D-HGS se incrementa sensiblemente la calidad de render en escenas con muchos bordes definidos y cambios bruscos de materiales, sin afectar negativamente el rendimiento. Los autores reportan que alcanzan el estado del arte en calidad de imagen (medido por métricas como PSNR/SSIM) al introducir half-Gaussians, manteniendo la velocidad de render similar al \textit{Gaussian Splatting} original. Esto último es posible ya que la rasterización de una media Gaussiana tiene costo equivalente a una normal (continúa siendo una primitiva elipsoidal, solo que con una región de soporte diferente). Por tanto, 3D-HGS representa una mejora focalizada: soluciona el problema con las discontinuidades que plagaba a 3DGS clásico (bordes borrosos, halos en contornos) proporcionando imágenes más nítidas y geometría más fiel (las reconstrucciones de profundidad presentan transiciones netas en las aristas de objetos). Una consideración es que, al introducir un corte, debe tenerse cuidado en la optimización para que la “mitad” Gaussiana quede correctamente alineada con el borde real; para ello, típicamente se utilizan criterios de detección de discontinuidad o gradientes de color que guían la orientación del plano de corte durante el entrenamiento. En combinación con técnicas de densificación adaptativa, 3D-HGS constituye una solución elegante que mejora sustancialmente la fidelidad local de la representación sin incurrir en grandes costos adicionales de cómputo ni en modificaciones complejas del algoritmo de renderizado.

%Region Deformable Beta Splatting
\subsection{Deformable Beta Splatting (DBS)}

Llevando aún más lejos la idea de flexibilizar la forma de las primitivas, el método \textbf{Deformable Beta Splatting (DBS)} introduce un nuevo tipo de kernel basado en funciones Beta esféricas deformables, en lugar de Gaussianas fijas [Deformable Beta Splatting]. Este método, recientemente desarrollado y aceptado en SIGGRAPH 2025, replantea el núcleo del splatting mediante dos innovaciones principales: (1) utiliza \textit{kernels Beta} en el espacio euclidiano para modelar la densidad espacial, y (2) emplea \textit{Betas esféricas} para capturar la dependencia de la vista, especialmente reflejos especulares. Las funciones Beta, ampliamente usadas en contextos estadísticos, tienen soporte \textit{acotado}, a diferencia de las Gaussianas que se extienden teóricamente al infinito, permitiendo además controlar explícitamente la forma de la distribución mediante parámetros específicos. 

En DBS, cada primitiva posee un parámetro $\alpha$ que controla cuán aguda o plana es la distribución. Con $\alpha=0$, la función se aproxima a una Gaussiana estándar; sin embargo, al optimizar este parámetro durante el entrenamiento, la primitiva puede deformarse dinámicamente, volviéndose más picuda (concentrando densidad en el centro) o más plana, con bordes claramente definidos. Durante la optimización, cada "splat" se \textit{adapta} a la geometría local; por ejemplo, las primitivas sobre superficies planas se aplanan significativamente para cubrir un área amplia y homogénea sin solapamientos indebidos, mientras que aquellas cercanas a detalles finos o vértices agudos se vuelven más puntiagudas para evitar interferencias con regiones vecinas. Debido al soporte finito inherente de las funciones Beta, desaparece el problema de las "colas largas" típico de las Gaussianas, limitando naturalmente el alcance de cada kernel a un radio definido y mejorando considerablemente la precisión espacial.

La flexibilidad de DBS tiene un notable impacto visual, superando por primera vez la calidad de métodos implícitos como NeRF en conjuntos de datos estándar, ofreciendo detalles de textura más definidos y geometrías más precisas [\cite{liu2025deformablebetasplatting}]. Por ejemplo, DBS reconstruye con alta precisión superficies planas, bordes definidos y detalles pequeños, mientras que 3DGS tiende a generar ligeros desenfoques o requiere un número considerablemente mayor de primitivas Gaussianas. Además, DBS mejora la eficiencia: gracias al aprovechamiento óptimo del soporte finito de cada primitiva, el número total de splats necesarios se reduce significativamente. En ciertas escenas, DBS logra resultados con un orden de magnitud menos primitivas que 3DGS, disminuyendo así tanto la memoria como el coste computacional.

Asimismo, el uso de Betas esféricas en el componente del color permite representar lóbulos especulares de forma directa, inspirado en el modelo de reflexión de Phong. Cada primitiva puede modelar reflexiones especulares mediante otra función Beta en el espacio direccional, permitiendo representar brillos y reflejos complejos sin necesidad de calcular explícitamente normales o depender exclusivamente de armónicos esféricos de baja frecuencia. Esto mejora considerablemente la calidad de representación de materiales brillantes, superando limitaciones típicas de los modelos Gaussianos esféricos que suelen truncar la reflectancia especular.

Es importante destacar que, para incorporar los kernels Beta deformables en el algoritmo de optimización, los autores tuvieron que rediseñar el esquema de densificación probabilística (MCMC) usado originalmente en 3DGS. Encontraron un enfoque general que regulariza las opacidades en lugar de modificar directamente la forma del kernel, permitiendo añadir nuevas primitivas de manera estable, sin depender de una formulación específica para Gaussianas.


%region Convex SPlatting
\subsection{Convex Splatting}

En \textbf{3D Convex Splatting (3DCS)}, otra propuesta reciente, se abandona completamente el concepto de kernel radial (Gaussianos, exponentiales, etc.) en favor de primitivas definidas por \textit{formas convexas suaves en 3D} [\cite{held20243dconvexsplattingradiance}]. El método representa la escena mediante un conjunto de volúmenes convexos (poliedros) con bordes suavizados, cada uno con parámetros que controlan tanto su tamaño y orientación como el grado de suavidad de sus fronteras. Intuitivamente, estas primitivas convexas pueden tomar la forma de cubos, prismas u otros poliedros “inflados” cuya superficie de contribución puede ser más dura o más difusa según sea necesario. Al entrenar, cada volumen convexo puede deformarse (siempre manteniéndose convexo) para adaptarse a la forma local de la escena, pudiendo así aproximar tanto superficies planas y aristas definidas (casos en que la primitiva se vuelve cercana a un poliedro rígido) como regiones de densidad difusa o volumétrica (casos en que la primitiva es pequeña y con bordes muy suaves).

El algoritmo de 3DCS inicia con pocas primitivas convexas grandes que cubren la escena de forma burda; luego realiza una densificación adaptativa similar a 3DGS, donde aquellas primitivas que abarcan zonas con alto error de render se subdividen en otras más pequeñas para capturar detalle fino. Cada paso de subdivisión agrega capacidad de detalle solo donde se necesita, evitando un crecimiento explosivo del número de primitivas. Gracias a la eficiencia de esta representación, los autores informan que con un 30\% menos de memoria que 3DGS logran incluso mejor fidelidad visual en escenas desafiantes. En particular, la ventaja de 3DCS se aprecia en entornos estructurados (como escenas de interiores con muchas paredes planas, esquinas rectas y objetos delineados): donde el \textit{Gaussian Splatting} tendería a difuminar ligeramente las aristas o requerir miles de splats para definir una esquina, un solo volumen convexo bien posicionado puede definir una pared entera con sus límites precisos. Las imágenes renderizadas con 3DCS exhiben bordes limpios y separación clara entre superficies contiguas. Además, debido a su carácter volumétrico explícito, la escena se descompone en elementos que tienen significado geométrico. Esta descomposición geométrica implícita es valiosa para análisis posteriores o para integración con \textit{pipelines} de gráficos: a diferencia de una nube de splats Gaussianos donde la forma global es difusa, aquí cada elemento tiene fronteras definidas que aproximan piezas del mundo real.

En términos de rendimiento, 3D Convex Splatting consigue todavía tasas de render por encima de tiempo real mediante un rasterizador especializado en GPU para sus primitivas convexas. No obstante, el costo es algo mayor que en 3DGS: la proyección y relleno de polígonos convexos, y el cálculo de sus contornos suaves en 2D, es más complejo que splat de un punto Gaussiano. En la práctica, se observó una pequeña reducción en FPS respecto al \textit{Gaussian Splatting} clásico, aunque manteniéndose en un rango aceptable para aplicaciones interactivas (por ejemplo, reducciones de 60 a \~40 FPS dependiendo de la escena). El entrenamiento también resulta un poco más lento, dado que optimizar la forma de volúmenes convexos conlleva más parámetros y restricciones que optimizar puntos Gauss (pues debe mantenerse la convexidad y suavidad). A pesar de ello, los beneficios en calidad (especialmente geométrica) posicionan a 3DCS como una alternativa prometedora, sobre todo para escenarios donde la estructura física de la escena es importante. En resumen, Convex Splatting demuestra que explorar primitivas volumétricas diferentes puede llevar a representaciones geométricamente más precisas, reduciendo la redundancia de elementos y mejorando la nitidez de la reconstrucción, a cambio de un ligero compromiso en la simplicidad y velocidad bruta del \textit{pipeline}.

%region DRK
\subsection{DRK (Deformable Radial Kernel Splatting)}

El trabajo \textbf{DRK} (\textit{Deformable Radial Kernel Splatting}) generaliza la noción de kernel radial mediante una combinación de bases radiales y transformaciones aprendibles, resultando en un primitiva extremadamente flexible [\cite{huang2025deformableradialkernelsplatting}]. En lugar de fijar una forma funcional (Gaussiana, Beta, etc.), DRK define cada splat con múltiples bases radiales elementales (por ejemplo, Gaussianas, cuadrados, triángulos u otras funciones radiales) que luego combina y deforma para ajustarse a la geometría local. Específicamente, se introducen parámetros aprendibles que controlan: (1) las orientaciones (ángulos polares) y escalas de cada base radial, permitiendo que el kernel final se estire, rote o encoja de forma anisótropa, y (2) una métrica de distancia híbrida (combinando normas $L_1$, $L_2$, etc. con pesos aprendidos) que le da al kernel la habilidad de generar isocontornos no circulares (por ejemplo, formas más cuadradas o rectangulares). Además, incorpora (3) una función de remapeo por tramos lineales adaptativa que ajusta la distribución de valores del kernel, pudiendo enfatizar o atenuar ciertas regiones (esto mejora aún más la capacidad de modelar bordes marcados). En suma, DRK provee un “\textit{superset}” de los kernels habituales: con la configuración adecuada, puede replicar un kernel Gaussiano tradicional, una media Gaussiana (cortando parte de la función con la métrica combinada), o incluso aproximar kernels de tipo Beta o convexos en cierto grado. Pero lo más importante es que puede adoptar formas intermedias que ninguno de los anteriores logra por sí solo, adaptándose dependientemente de los datos de entrenamiento.

El resultado práctico de esta libertad es que DRK puede modelar primitivas de forma muy compleja con menos elementos. En contextos 3D, esto significa que superficies con esquinas agudas, ranuras, o texturas de alto contraste pueden ser representadas fielmente con un puñado de kernels DRK, donde métodos previos necesitarían atomizar la escena en infinidad de pequeños splats. En términos de calidad, DRK logra reproducir transiciones abruptas y formas no-gaussianas casi a la perfección, eliminando esencialmente el suavizado no deseado. A pesar de su complejidad conceptual, DRK está diseñado para mantener un esquema de renderización eficiente: sus kernels deformables aún se pueden evaluar de forma cerrada y renderizar mediante splatting sin ordenar exhaustivamente (aprovechando la estructura radial base para proyectar y luego aplicando correcciones locales). Los experimentos muestran que la representación resultante conserva la eficiencia de render cercano a tiempo real, y la optimización de sus parámetros, aunque más costosa por la cantidad de grados de libertad, converge gracias a la formulación diferenciable bien condicionada que plantean. En definitiva, DRK extiende el paradigma de splatting a un marco mucho más general y expresivo: en vez de cambiar globalmente de función, permite que cada primitiva esculpa su propia función radial óptima para la porción de escena que cubre. DRK ejemplifica el punto al que ha llegado la investigación: diseñar kernels adaptativos que unifiquen las lecciones de trabajos previos (cortes para discontinuidades, funciones agudas para bordes, anisotropía para texturas direccionales, etc.) en un solo formalismo.

%region Disc-GS
\subsection{Disc-GS (Discontinuity-aware Gaussian Splatting)}

Antes de pasar a las representaciones volumétricas alternativas, cabe mencionar \textbf{DisC-GS}, un método enfocado específicamente en mejorar el manejo de discontinuidades en el \textit{Gaussian Splatting} [\cite{qu2024discgsdiscontinuityawaregaussiansplatting}]. Este enfoque introduce modificaciones en el pipeline del Gaussian Splatting para detectar y preservar bordes duros en la imagen. En esencia, DisC-GS habilita que la contribución de un splat Gaussiano pueda “cortarse” o limitarse adaptativamente en aquellas zonas donde solaparía regiones de profundidad muy distintas. Por ejemplo, si un Gaussiano abarca píxeles pertenecientes a dos objetos separados por un borde (diferente profundidad o diferente color abruptamente), el algoritmo ajusta la distribución o subdivide el splat de modo que no genere un blending inapropiado entre ambos lados de la discontinuidad. Para lograr esto, DisC-GS incorpora en la optimización un término de conciencia de bordes: utiliza gradientes de la imagen renderizada o heurísticas de discontinuidad para guiar la colocación y forma de los Gaussianos, incentivando que no atraviesen fronteras altas de error reproyectado. Así, los splats tienden a alinearse con la geometría en vez de difuminarla.

Los resultados de DisC-GS muestran mejoras claras en la nitidez de bordes y contornos con respecto al \textit{Gaussian Splatting} original. Las imágenes producidas tienen menos “halos” o fugas de color en los bordes de objetos, y las siluetas se perciben más definidas. Todo esto se logra manteniendo el rendimiento en tiempo real, ya que DisC-GS no añade cálculo complejo en el bucle de renderizado, sino que afecta principalmente la etapa de construcción/optimización de la representación. En la práctica, DisC-GS complementa bien a métodos como 3D-HGS: ambos comparten el objetivo de respetar discontinuidades, pero mientras 3D-HGS lo hace mediante un cambio de kernel (cortar la función en origen), DisC-GS lo implementa como una estrategia de colocación y adaptación de múltiples Gaussianas normales. Su ventaja es su simplicidad y compatibilidad: cualquier pipeline de splatting existente puede beneficiarse de incorporar los criterios de DisC-GS para afinar la distribución de sus splats. 

%region Otras
\section{Otras representaciones volumétricas}

Además de las aproximaciones basadas en splatting y primitivas adaptativas, existen otras representaciones volumétricas explícitas que han surgido para el \textit{novel view synthesis} con alta eficiencia. A continuación, se describen dos de estas representaciones, comparando su eficiencia y calidad con los métodos de splatting.

%region Sparse VOcels Rasterization
\subsection{Sparse Voxels Rasterization}

La \textbf{rasterización de voxeles dispersos} (Sparse Voxels Rasterization) es un método propuesto por investigadores de NVIDIA que busca combinar la representación explícita tipo voxel con un proceso de render estilo rasterización para lograr visualización en tiempo real de campos de radiancia densos [\cite{sun2024sparse}]. La idea central es optimizar un volumen de voxeles adaptativamente subdividido (en un árbol octree) a partir de imágenes, pero a la hora de renderizar, en lugar de hacer muestreo ray-marching tradicional, se realiza un \textit{rasterizado} de los voxeles hacia la cámara. En la práctica, esto significa proyectar cada voxel no vacío (que contiene densidad y color) a la pantalla, ordenándolos por profundidad, y componer sus contribuciones. Puede verse como un caso particular de splatting donde las primitivas ya no son Gaussianas ni funciones suaves sino pequeñas “cajas” de volumen constante.

Para lograr eficiencia, el método emplea voxeles de tamaño variable: utiliza un esquema de octree en el que los voxeles hojas pueden tener distintos niveles de tamaño dependiendo de la complejidad local de la escena (adaptative grid). Todos los voxeles ocupados (no vacíos) se almacenan en estructuras lineales eficientes y se proyectan mediante shaders GPU aprovechando que son convexos y de caras planas, lo que simplifica la determinación de su huella en la en pantalla. Un aspecto importante es que la técnica prescinde totalmente de redes neuronales durante el render: no hay MLP evaluándose por punto como en NeRF, lo cual elimina cuellos de botella computacionales. El resultado es sorprendentemente rápido: se reporta que esta rasterización de voxeles alcanza cientos de cuadros por segundo en escenas estándar, logrando incluso alrededor de 900 FPS en algunos casos simplificados, manteniendo la fidelidad cercana a la de representaciones neuronales volumétricas. Esto supone que, con hardware GPU actual, es posible visualizar campos de radiancia con calidad alta de manera prácticamente instantánea, habilitando aplicaciones interactivas de realidad virtual o editores 3D basados en dichas representaciones.

%region Radiant Foam
\subsection{Radiant Foam}

Por último, \textbf{Radiant Foam} es una representación volumétrica reciente que adopta un enfoque basado en celdas poliedrales para lograr trazado de rayos diferenciable en tiempo real [\cite{govindarajan2025radiant}]. Este método subdivide la escena en una multitud de pequeñas celdas volumétricas de forma poliédrica (análogas a burbujas de espuma que llenan el espacio). Cada celda contiene un valor constante de densidad y radiancia, y el conjunto de celdas conforma una partición (aproximada) del volumen de la escena. A diferencia del \textit{Gaussian Splatting} y métodos similares, Radiant Foam realiza el renderizado mediante ray tracing a través de las celdas: un rayo lanzado desde la cámara avanzará atravesando sucesivamente estas celdas, sumando las contribuciones de color/absorción de cada una, hasta salir de la escena o agotar su energía. Dado que las celdas tienen fronteras planas y son convexas, es posible calcular de forma determinista el punto de salida de un rayo de cada celda (intersección con sus caras) y así encadenar el recorrido del rayo por el espacio de manera exacta.

Radiant Foam consigue velocidades y calidad comparables a \textit{3D Gaussian Splatting}, pero con algunas ventajas añadidas. Al basarse en ray tracing volumétrico, es inmune a los artefactos de \textit{popping} de la rasterización: la salida es perfectamente consistente entre vistas, ya que la integración volumétrica no depende de un orden global arbitrario sino de la física del rayo. Asimismo, habilita de manera natural efectos de transparencia, refracción y reflexión sencillas, dado que la representación volumétrica puede extenderse para simular estos fenómenos (por ejemplo, un rayo puede dividirse o cambiar de dirección en interfaces si se modelan índices de refracción, cosa inviable en splatting puro). De hecho, Radiant Foam fue concebido en parte para superar limitaciones de rasterización identificadas en 3DGS: dificultades con lentes ojo de pez, con transparencia o con iluminación más compleja. En Radiant Foam, incorporar un efecto de lente distorsionada simplemente implica ajustar la trayectoria inicial de los rayos; manejar transparencia implica permitir que ciertos voxels/celdas no absorban totalmente la luz de fondo, etc., todo factible dentro del marco de ray tracing sin reestructurar el algoritmo.
